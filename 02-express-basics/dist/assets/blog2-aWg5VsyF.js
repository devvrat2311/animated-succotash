import{j as e}from"./index-BOuz-hHw.js";function l(){const n={height:"40vh",display:"block",margin:"auto"},i={color:"var(--color-secondary)",marginBottom:0},s={color:"var(--color-secondary)"},t={lineHeight:"1.3rem",fontSize:"1.1rem"},a={display:"inline"},o={marginBottom:0};return e.jsxs("main",{children:[e.jsx("h1",{style:{color:"var(--foreground-dark)"},children:"GNU Make Utility"}),e.jsx("h2",{style:i,children:"What is Make?"}),e.jsxs("p",{style:t,children:["Make is a tool provided by GNU that at its very core can run certain commands whenever certain conditions are met. These commands are either native to the shell (system manipulation/navigation commands in bash like `ls`, `cd`, `mkdir`, etc.) or they are compiler instructions (building object files, linking them, creating executables, etc.) pertaining to any language whose compiler can be run with a shell command. The"," ",e.jsx("a",{href:"https://archive.org/details/gnumake00rich_j85",style:s,children:"book"})," ",'written by the creators of GNU Make Richard Stallman, Roland McGrath, Paul Smith defines Make as "a utility that automatically determines which pieces of a large program need to be recompiled, and issues commands to recompile them".']}),e.jsx("img",{src:"https://archive.org/services/img/gnumakeprogramfo0000stal/full/pct:200/0/default.jpg",style:n,alt:"GNU Make Book"}),e.jsx("h2",{style:i,children:"What are Makefiles?"}),e.jsxs("p",{style:t,children:["Since the Make utility implements instructions, there must be a way to write those instructions in a structural manner. A Makefile is exactly that, a bunch of coherent instructions that Make can follow to update or build program files. Once a suitable makefile exists, each time any changes to the source files occur, a simple shell command:",e.jsx("code",{children:"make"}),"suffices to perform all necessary recompilations."]}),e.jsxs("p",{style:t,children:["A makefile is a collection of 'rules', these rules need to follow a particular syntax. A generic rule looks like this.",e.jsx("pre",{children:e.jsx("code",{children:`target ... : prerequisites ...
<T A B> recipe
        ...
        ...
`})}),"where the '...' symbol signifies that there can be more than one target, prerequisite or recipe.",e.jsx("h3",{style:o,children:"Target"})," is usually the name of a file that is generated by a program. Examples of targets are executable or object files. A target can also be the name of action to carry out.(Phony Targets) ",e.jsx("h3",{style:o,children:"Prerequisites"})," are files used as input to create the target. Prerequisites are multiple in number more often than not.",e.jsx("h3",{style:o,children:"Recipe"})," is an action that"," ",e.jsx("code",{style:a,children:"make"})," carries out. A recipe may have more than one command, either on the same line or on its own line. Note that each recipe line MUST HAVE A"," ",e.jsx("code",{style:a,children:"<TAB>"})," CHARACTER at the beginning."]}),e.jsx("h2",{style:i,children:"A simple scenario"}),e.jsxs("p",{style:t,children:["We will now see what a barebones makefile can do through a simple scenario. Say I have a project i'm working on. It is written in C++, has 3 files :",e.jsx("pre",{children:e.jsx("code",{children:`//this is foo.hpp
#pragma once

void some_func(int);
`})}),e.jsx("pre",{children:e.jsx("code",{children:`//this is foo.cpp
#include "./foo.hpp"
#include <iostream>

void some_func(int bar) {
  while(bar--)
    std::cout << "something in the way" << std::endl;
}
`})}),e.jsx("pre",{children:e.jsx("code",{children:`//this is main.cpp
#include "./foo.hpp"

int main() {
  some_func(2);
  return 0;
}
`})}),'where "foo.cpp" along with "foo.hpp" is a user defined library to be used in "main.cpp". In order to get this compiled and running, I have to follow two simple procedures.',e.jsx("h3",{style:o,children:"1. make object files from .cpp files"}),e.jsx("code",{children:" g++ -c main.cpp foo.cpp "}),"this will create two object files main.o and foo.o and everytime I make changes to either main.cpp or foo.cpp, I will require a new object file to reflect the changes corresponding to the file I edited.",e.jsx("h3",{style:o,children:"2. make the final executable from the object files"}),e.jsx("code",{children:" g++ main.o foo.o -o myExecutable "}),"this will create the final executable called"," ",e.jsx("code",{style:a,children:"myExecutable"})," in the same folder. Which I can then run by"," ",e.jsx("code",{style:a,children:"./myExecutable"}),"."]}),e.jsx("h2",{style:i,children:"The Problem :("}),e.jsx("p",{style:t,children:"Throughout the development of my project I will make changes to foo.cpp and main.cpp many many times! As the project grows larger with more files, am I expected to write the compile instructions everytime? If only ... there was a way automate this process."}),e.jsx("h2",{style:i,children:"The Solution! :)"}),e.jsx("p",{style:t,children:"This is exactly why the GNU Make utility exists! Let's use Make and write a simple makefile to do the building for us. Following is a barebones makefile to automate the compilation process."}),e.jsx("pre",{children:e.jsx("code",{children:`
myExecutable : main.o foo.o
	g++ main.o foo.o -o myExecutable

main.o : main.cpp
	g++ -c main.cpp

foo.o : foo.cpp
	g++ -c foo.cpp

clean:
	rm myExecutable main.o foo.o

`})}),e.jsx("p",{children:"The wildcard '*' can be used to further simplify the makefile."}),e.jsx("pre",{children:e.jsx("code",{children:`
myExecutable : *.o
        g++ *.o -o myExecutable

*.o : *.cpp
        g++ -c *.cpp

clean:
        rm myExecutable *.o

`})}),e.jsxs("p",{style:t,children:["A makefile works in a bottom up manner when looking for tasks in a kind of oxymoronic way. When reading a makefile, the program first reads the targets' prerequisites/dependencies starting with the topmost target. It then keeps moving down the chain of dependencies to reach the most basic target dependency pair. It then starts processing the recipe instructions given for the particular target block, and once it has reached its target proceeds to a level higher in the buildchain until it has reached the topmost target.",e.jsx("h3",{style:o,children:"Explanation of the above example"}),"In the makefile we wrote, the execution starts with seeing the target 'myExecutable' and its dependencies 'main.o' and 'foo.o'. Then it looks for the targets 'main.o' and 'foo.o' and checks if their dependencies exist or not. Since 'main.cpp' and 'foo.cpp' exist in the directory, it starts the process by running the recipe under this block which then creates the object files required for the target 'myExecutable' to run! Since there is no target which is expecting a myExecutable as a dependency, our make process finishes here. 'Clean' is a build instruction that removes the object/exe files for those who like to"," ",e.jsx("code",{style:a,children:"ls"}),"to a neat look."]}),e.jsx("h2",{style:i,children:"Summing Up"}),e.jsxs("p",{style:t,children:["I wrote this article because I feel that Make is an amazing tool! And the skill to write an elegant, to the point makefile, is a great skill to have. Whether just developing solo or writing open source software for others to collaborate on, Make makes for a great tool to build software cross platform(although a GNU initiative, make works on windows and mac as well!). I would definitely recommend going over the"," ",e.jsx("a",{href:"https://archive.org/details/gnumake00rich_j85",style:s,children:"book"})," ","written by the original developers of Make. I use some advanced makefiles in my projects, head on over to the Projects tab to explore more!"]})]})}export{l as default};
